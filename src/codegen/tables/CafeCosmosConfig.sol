// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { FieldLayout } from "@latticexyz/store/src/FieldLayout.sol";
import { Schema } from "@latticexyz/store/src/Schema.sol";
import { EncodedLengths, EncodedLengthsLib } from "@latticexyz/store/src/EncodedLengths.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";

struct CafeCosmosConfigData {
  uint256 cookingCost;
  uint256 softCostPerSquare;
  uint256 landNonce;
  uint256 initialLimitX;
  uint256 initialLimitY;
  uint256 minStartingX;
  uint256 minStartingY;
  uint256 totalLandSlotsSold;
  uint256 startTime;
  uint256 defaultLandType;
  uint160 seedMask;
  uint256 globalBoosterId;
  uint256 maxGroupIdNumber;
  uint256 chunkSize;
  uint256 maxLevel;
  uint256[7] categoryMaxBoost;
  uint256[3] maxBoosts;
  uint256[] startingItems;
  uint256[] startingItemsQuantities;
}

library CafeCosmosConfig {
  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: "", name: "CafeCosmosConfig", typeId: RESOURCE_TABLE });`
  ResourceId constant _tableId = ResourceId.wrap(0x7462000000000000000000000000000043616665436f736d6f73436f6e666967);

  FieldLayout constant _fieldLayout =
    FieldLayout.wrap(0x01d40f0420202020202020202020142020202000000000000000000000000000);

  // Hex-encoded key schema of ()
  Schema constant _keySchema = Schema.wrap(0x0000000000000000000000000000000000000000000000000000000000000000);
  // Hex-encoded value schema of (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint160, uint256, uint256, uint256, uint256, uint256[], uint256[], uint256[], uint256[])
  Schema constant _valueSchema = Schema.wrap(0x01d40f041f1f1f1f1f1f1f1f1f1f131f1f1f1f81818181000000000000000000);

  /**
   * @notice Get the table's key field names.
   * @return keyNames An array of strings with the names of key fields.
   */
  function getKeyNames() internal pure returns (string[] memory keyNames) {
    keyNames = new string[](0);
  }

  /**
   * @notice Get the table's value field names.
   * @return fieldNames An array of strings with the names of value fields.
   */
  function getFieldNames() internal pure returns (string[] memory fieldNames) {
    fieldNames = new string[](19);
    fieldNames[0] = "cookingCost";
    fieldNames[1] = "softCostPerSquare";
    fieldNames[2] = "landNonce";
    fieldNames[3] = "initialLimitX";
    fieldNames[4] = "initialLimitY";
    fieldNames[5] = "minStartingX";
    fieldNames[6] = "minStartingY";
    fieldNames[7] = "totalLandSlotsSold";
    fieldNames[8] = "startTime";
    fieldNames[9] = "defaultLandType";
    fieldNames[10] = "seedMask";
    fieldNames[11] = "globalBoosterId";
    fieldNames[12] = "maxGroupIdNumber";
    fieldNames[13] = "chunkSize";
    fieldNames[14] = "maxLevel";
    fieldNames[15] = "categoryMaxBoost";
    fieldNames[16] = "maxBoosts";
    fieldNames[17] = "startingItems";
    fieldNames[18] = "startingItemsQuantities";
  }

  /**
   * @notice Register the table with its config.
   */
  function register() internal {
    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Register the table with its config.
   */
  function _register() internal {
    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Get cookingCost.
   */
  function getCookingCost() internal view returns (uint256 cookingCost) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get cookingCost.
   */
  function _getCookingCost() internal view returns (uint256 cookingCost) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set cookingCost.
   */
  function setCookingCost(uint256 cookingCost) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((cookingCost)), _fieldLayout);
  }

  /**
   * @notice Set cookingCost.
   */
  function _setCookingCost(uint256 cookingCost) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((cookingCost)), _fieldLayout);
  }

  /**
   * @notice Get softCostPerSquare.
   */
  function getSoftCostPerSquare() internal view returns (uint256 softCostPerSquare) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get softCostPerSquare.
   */
  function _getSoftCostPerSquare() internal view returns (uint256 softCostPerSquare) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set softCostPerSquare.
   */
  function setSoftCostPerSquare(uint256 softCostPerSquare) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked((softCostPerSquare)), _fieldLayout);
  }

  /**
   * @notice Set softCostPerSquare.
   */
  function _setSoftCostPerSquare(uint256 softCostPerSquare) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked((softCostPerSquare)), _fieldLayout);
  }

  /**
   * @notice Get landNonce.
   */
  function getLandNonce() internal view returns (uint256 landNonce) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get landNonce.
   */
  function _getLandNonce() internal view returns (uint256 landNonce) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set landNonce.
   */
  function setLandNonce(uint256 landNonce) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked((landNonce)), _fieldLayout);
  }

  /**
   * @notice Set landNonce.
   */
  function _setLandNonce(uint256 landNonce) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked((landNonce)), _fieldLayout);
  }

  /**
   * @notice Get initialLimitX.
   */
  function getInitialLimitX() internal view returns (uint256 initialLimitX) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 3, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get initialLimitX.
   */
  function _getInitialLimitX() internal view returns (uint256 initialLimitX) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 3, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set initialLimitX.
   */
  function setInitialLimitX(uint256 initialLimitX) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 3, abi.encodePacked((initialLimitX)), _fieldLayout);
  }

  /**
   * @notice Set initialLimitX.
   */
  function _setInitialLimitX(uint256 initialLimitX) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 3, abi.encodePacked((initialLimitX)), _fieldLayout);
  }

  /**
   * @notice Get initialLimitY.
   */
  function getInitialLimitY() internal view returns (uint256 initialLimitY) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 4, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get initialLimitY.
   */
  function _getInitialLimitY() internal view returns (uint256 initialLimitY) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 4, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set initialLimitY.
   */
  function setInitialLimitY(uint256 initialLimitY) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 4, abi.encodePacked((initialLimitY)), _fieldLayout);
  }

  /**
   * @notice Set initialLimitY.
   */
  function _setInitialLimitY(uint256 initialLimitY) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 4, abi.encodePacked((initialLimitY)), _fieldLayout);
  }

  /**
   * @notice Get minStartingX.
   */
  function getMinStartingX() internal view returns (uint256 minStartingX) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 5, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get minStartingX.
   */
  function _getMinStartingX() internal view returns (uint256 minStartingX) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 5, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set minStartingX.
   */
  function setMinStartingX(uint256 minStartingX) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 5, abi.encodePacked((minStartingX)), _fieldLayout);
  }

  /**
   * @notice Set minStartingX.
   */
  function _setMinStartingX(uint256 minStartingX) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 5, abi.encodePacked((minStartingX)), _fieldLayout);
  }

  /**
   * @notice Get minStartingY.
   */
  function getMinStartingY() internal view returns (uint256 minStartingY) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 6, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get minStartingY.
   */
  function _getMinStartingY() internal view returns (uint256 minStartingY) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 6, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set minStartingY.
   */
  function setMinStartingY(uint256 minStartingY) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 6, abi.encodePacked((minStartingY)), _fieldLayout);
  }

  /**
   * @notice Set minStartingY.
   */
  function _setMinStartingY(uint256 minStartingY) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 6, abi.encodePacked((minStartingY)), _fieldLayout);
  }

  /**
   * @notice Get totalLandSlotsSold.
   */
  function getTotalLandSlotsSold() internal view returns (uint256 totalLandSlotsSold) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 7, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get totalLandSlotsSold.
   */
  function _getTotalLandSlotsSold() internal view returns (uint256 totalLandSlotsSold) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 7, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set totalLandSlotsSold.
   */
  function setTotalLandSlotsSold(uint256 totalLandSlotsSold) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 7, abi.encodePacked((totalLandSlotsSold)), _fieldLayout);
  }

  /**
   * @notice Set totalLandSlotsSold.
   */
  function _setTotalLandSlotsSold(uint256 totalLandSlotsSold) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 7, abi.encodePacked((totalLandSlotsSold)), _fieldLayout);
  }

  /**
   * @notice Get startTime.
   */
  function getStartTime() internal view returns (uint256 startTime) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 8, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get startTime.
   */
  function _getStartTime() internal view returns (uint256 startTime) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 8, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set startTime.
   */
  function setStartTime(uint256 startTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 8, abi.encodePacked((startTime)), _fieldLayout);
  }

  /**
   * @notice Set startTime.
   */
  function _setStartTime(uint256 startTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 8, abi.encodePacked((startTime)), _fieldLayout);
  }

  /**
   * @notice Get defaultLandType.
   */
  function getDefaultLandType() internal view returns (uint256 defaultLandType) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 9, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get defaultLandType.
   */
  function _getDefaultLandType() internal view returns (uint256 defaultLandType) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 9, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set defaultLandType.
   */
  function setDefaultLandType(uint256 defaultLandType) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 9, abi.encodePacked((defaultLandType)), _fieldLayout);
  }

  /**
   * @notice Set defaultLandType.
   */
  function _setDefaultLandType(uint256 defaultLandType) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 9, abi.encodePacked((defaultLandType)), _fieldLayout);
  }

  /**
   * @notice Get seedMask.
   */
  function getSeedMask() internal view returns (uint160 seedMask) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 10, _fieldLayout);
    return (uint160(bytes20(_blob)));
  }

  /**
   * @notice Get seedMask.
   */
  function _getSeedMask() internal view returns (uint160 seedMask) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 10, _fieldLayout);
    return (uint160(bytes20(_blob)));
  }

  /**
   * @notice Set seedMask.
   */
  function setSeedMask(uint160 seedMask) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 10, abi.encodePacked((seedMask)), _fieldLayout);
  }

  /**
   * @notice Set seedMask.
   */
  function _setSeedMask(uint160 seedMask) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 10, abi.encodePacked((seedMask)), _fieldLayout);
  }

  /**
   * @notice Get globalBoosterId.
   */
  function getGlobalBoosterId() internal view returns (uint256 globalBoosterId) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 11, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get globalBoosterId.
   */
  function _getGlobalBoosterId() internal view returns (uint256 globalBoosterId) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 11, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set globalBoosterId.
   */
  function setGlobalBoosterId(uint256 globalBoosterId) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 11, abi.encodePacked((globalBoosterId)), _fieldLayout);
  }

  /**
   * @notice Set globalBoosterId.
   */
  function _setGlobalBoosterId(uint256 globalBoosterId) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 11, abi.encodePacked((globalBoosterId)), _fieldLayout);
  }

  /**
   * @notice Get maxGroupIdNumber.
   */
  function getMaxGroupIdNumber() internal view returns (uint256 maxGroupIdNumber) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 12, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get maxGroupIdNumber.
   */
  function _getMaxGroupIdNumber() internal view returns (uint256 maxGroupIdNumber) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 12, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set maxGroupIdNumber.
   */
  function setMaxGroupIdNumber(uint256 maxGroupIdNumber) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 12, abi.encodePacked((maxGroupIdNumber)), _fieldLayout);
  }

  /**
   * @notice Set maxGroupIdNumber.
   */
  function _setMaxGroupIdNumber(uint256 maxGroupIdNumber) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 12, abi.encodePacked((maxGroupIdNumber)), _fieldLayout);
  }

  /**
   * @notice Get chunkSize.
   */
  function getChunkSize() internal view returns (uint256 chunkSize) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 13, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get chunkSize.
   */
  function _getChunkSize() internal view returns (uint256 chunkSize) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 13, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set chunkSize.
   */
  function setChunkSize(uint256 chunkSize) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 13, abi.encodePacked((chunkSize)), _fieldLayout);
  }

  /**
   * @notice Set chunkSize.
   */
  function _setChunkSize(uint256 chunkSize) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 13, abi.encodePacked((chunkSize)), _fieldLayout);
  }

  /**
   * @notice Get maxLevel.
   */
  function getMaxLevel() internal view returns (uint256 maxLevel) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 14, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get maxLevel.
   */
  function _getMaxLevel() internal view returns (uint256 maxLevel) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 14, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set maxLevel.
   */
  function setMaxLevel(uint256 maxLevel) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setStaticField(_tableId, _keyTuple, 14, abi.encodePacked((maxLevel)), _fieldLayout);
  }

  /**
   * @notice Set maxLevel.
   */
  function _setMaxLevel(uint256 maxLevel) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setStaticField(_tableId, _keyTuple, 14, abi.encodePacked((maxLevel)), _fieldLayout);
  }

  /**
   * @notice Get categoryMaxBoost.
   */
  function getCategoryMaxBoost() internal view returns (uint256[7] memory categoryMaxBoost) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);
    return toStaticArray_uint256_7(SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Get categoryMaxBoost.
   */
  function _getCategoryMaxBoost() internal view returns (uint256[7] memory categoryMaxBoost) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);
    return toStaticArray_uint256_7(SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Set categoryMaxBoost.
   */
  function setCategoryMaxBoost(uint256[7] memory categoryMaxBoost) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setDynamicField(
      _tableId,
      _keyTuple,
      0,
      EncodeArray.encode(fromStaticArray_uint256_7(categoryMaxBoost))
    );
  }

  /**
   * @notice Set categoryMaxBoost.
   */
  function _setCategoryMaxBoost(uint256[7] memory categoryMaxBoost) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode(fromStaticArray_uint256_7(categoryMaxBoost)));
  }

  // The length of categoryMaxBoost
  uint256 constant lengthCategoryMaxBoost = 7;

  /**
   * @notice Get an item of categoryMaxBoost.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemCategoryMaxBoost(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);
    uint256 dynamicLength = _byteLength / 32;
    uint256 staticLength = 7;

    if (_index < staticLength && _index >= dynamicLength) {
      return (uint256(bytes32(new bytes(0))));
    }

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Get an item of categoryMaxBoost.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemCategoryMaxBoost(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);
    uint256 dynamicLength = _byteLength / 32;
    uint256 staticLength = 7;

    if (_index < staticLength && _index >= dynamicLength) {
      return (uint256(bytes32(new bytes(0))));
    }

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Update an element of categoryMaxBoost at `_index`.
   */
  function updateCategoryMaxBoost(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of categoryMaxBoost at `_index`.
   */
  function _updateCategoryMaxBoost(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get maxBoosts.
   */
  function getMaxBoosts() internal view returns (uint256[3] memory maxBoosts) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 1);
    return toStaticArray_uint256_3(SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Get maxBoosts.
   */
  function _getMaxBoosts() internal view returns (uint256[3] memory maxBoosts) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 1);
    return toStaticArray_uint256_3(SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Set maxBoosts.
   */
  function setMaxBoosts(uint256[3] memory maxBoosts) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 1, EncodeArray.encode(fromStaticArray_uint256_3(maxBoosts)));
  }

  /**
   * @notice Set maxBoosts.
   */
  function _setMaxBoosts(uint256[3] memory maxBoosts) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setDynamicField(_tableId, _keyTuple, 1, EncodeArray.encode(fromStaticArray_uint256_3(maxBoosts)));
  }

  // The length of maxBoosts
  uint256 constant lengthMaxBoosts = 3;

  /**
   * @notice Get an item of maxBoosts.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemMaxBoosts(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 1);
    uint256 dynamicLength = _byteLength / 32;
    uint256 staticLength = 3;

    if (_index < staticLength && _index >= dynamicLength) {
      return (uint256(bytes32(new bytes(0))));
    }

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Get an item of maxBoosts.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemMaxBoosts(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 1);
    uint256 dynamicLength = _byteLength / 32;
    uint256 staticLength = 3;

    if (_index < staticLength && _index >= dynamicLength) {
      return (uint256(bytes32(new bytes(0))));
    }

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Update an element of maxBoosts at `_index`.
   */
  function updateMaxBoosts(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of maxBoosts at `_index`.
   */
  function _updateMaxBoosts(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get startingItems.
   */
  function getStartingItems() internal view returns (uint256[] memory startingItems) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 2);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Get startingItems.
   */
  function _getStartingItems() internal view returns (uint256[] memory startingItems) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 2);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Set startingItems.
   */
  function setStartingItems(uint256[] memory startingItems) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 2, EncodeArray.encode((startingItems)));
  }

  /**
   * @notice Set startingItems.
   */
  function _setStartingItems(uint256[] memory startingItems) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setDynamicField(_tableId, _keyTuple, 2, EncodeArray.encode((startingItems)));
  }

  /**
   * @notice Get the length of startingItems.
   */
  function lengthStartingItems() internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 2);
    unchecked {
      return _byteLength / 32;
    }
  }

  /**
   * @notice Get the length of startingItems.
   */
  function _lengthStartingItems() internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 2);
    unchecked {
      return _byteLength / 32;
    }
  }

  /**
   * @notice Get an item of startingItems.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemStartingItems(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 2, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Get an item of startingItems.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemStartingItems(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 2, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Push an element to startingItems.
   */
  function pushStartingItems(uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 2, abi.encodePacked((_element)));
  }

  /**
   * @notice Push an element to startingItems.
   */
  function _pushStartingItems(uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 2, abi.encodePacked((_element)));
  }

  /**
   * @notice Pop an element from startingItems.
   */
  function popStartingItems() internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 2, 32);
  }

  /**
   * @notice Pop an element from startingItems.
   */
  function _popStartingItems() internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 2, 32);
  }

  /**
   * @notice Update an element of startingItems at `_index`.
   */
  function updateStartingItems(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 2, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of startingItems at `_index`.
   */
  function _updateStartingItems(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 2, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get startingItemsQuantities.
   */
  function getStartingItemsQuantities() internal view returns (uint256[] memory startingItemsQuantities) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 3);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Get startingItemsQuantities.
   */
  function _getStartingItemsQuantities() internal view returns (uint256[] memory startingItemsQuantities) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 3);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /**
   * @notice Set startingItemsQuantities.
   */
  function setStartingItemsQuantities(uint256[] memory startingItemsQuantities) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 3, EncodeArray.encode((startingItemsQuantities)));
  }

  /**
   * @notice Set startingItemsQuantities.
   */
  function _setStartingItemsQuantities(uint256[] memory startingItemsQuantities) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setDynamicField(_tableId, _keyTuple, 3, EncodeArray.encode((startingItemsQuantities)));
  }

  /**
   * @notice Get the length of startingItemsQuantities.
   */
  function lengthStartingItemsQuantities() internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 3);
    unchecked {
      return _byteLength / 32;
    }
  }

  /**
   * @notice Get the length of startingItemsQuantities.
   */
  function _lengthStartingItemsQuantities() internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 3);
    unchecked {
      return _byteLength / 32;
    }
  }

  /**
   * @notice Get an item of startingItemsQuantities.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemStartingItemsQuantities(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 3, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Get an item of startingItemsQuantities.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemStartingItemsQuantities(uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 3, _index * 32, (_index + 1) * 32);
      return (uint256(bytes32(_blob)));
    }
  }

  /**
   * @notice Push an element to startingItemsQuantities.
   */
  function pushStartingItemsQuantities(uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 3, abi.encodePacked((_element)));
  }

  /**
   * @notice Push an element to startingItemsQuantities.
   */
  function _pushStartingItemsQuantities(uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 3, abi.encodePacked((_element)));
  }

  /**
   * @notice Pop an element from startingItemsQuantities.
   */
  function popStartingItemsQuantities() internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 3, 32);
  }

  /**
   * @notice Pop an element from startingItemsQuantities.
   */
  function _popStartingItemsQuantities() internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 3, 32);
  }

  /**
   * @notice Update an element of startingItemsQuantities at `_index`.
   */
  function updateStartingItemsQuantities(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 3, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of startingItemsQuantities at `_index`.
   */
  function _updateStartingItemsQuantities(uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 3, uint40(_index * 32), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get the full data.
   */
  function get() internal view returns (CafeCosmosConfigData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreSwitch.getRecord(
      _tableId,
      _keyTuple,
      _fieldLayout
    );
    return decode(_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Get the full data.
   */
  function _get() internal view returns (CafeCosmosConfigData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreCore.getRecord(
      _tableId,
      _keyTuple,
      _fieldLayout
    );
    return decode(_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function set(
    uint256 cookingCost,
    uint256 softCostPerSquare,
    uint256 landNonce,
    uint256 initialLimitX,
    uint256 initialLimitY,
    uint256 minStartingX,
    uint256 minStartingY,
    uint256 totalLandSlotsSold,
    uint256 startTime,
    uint256 defaultLandType,
    uint160 seedMask,
    uint256 globalBoosterId,
    uint256 maxGroupIdNumber,
    uint256 chunkSize,
    uint256 maxLevel,
    uint256[7] memory categoryMaxBoost,
    uint256[3] memory maxBoosts,
    uint256[] memory startingItems,
    uint256[] memory startingItemsQuantities
  ) internal {
    bytes memory _staticData = encodeStatic(
      cookingCost,
      softCostPerSquare,
      landNonce,
      initialLimitX,
      initialLimitY,
      minStartingX,
      minStartingY,
      totalLandSlotsSold,
      startTime,
      defaultLandType,
      seedMask,
      globalBoosterId,
      maxGroupIdNumber,
      chunkSize,
      maxLevel
    );

    EncodedLengths _encodedLengths = encodeLengths(categoryMaxBoost, maxBoosts, startingItems, startingItemsQuantities);
    bytes memory _dynamicData = encodeDynamic(categoryMaxBoost, maxBoosts, startingItems, startingItemsQuantities);

    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function _set(
    uint256 cookingCost,
    uint256 softCostPerSquare,
    uint256 landNonce,
    uint256 initialLimitX,
    uint256 initialLimitY,
    uint256 minStartingX,
    uint256 minStartingY,
    uint256 totalLandSlotsSold,
    uint256 startTime,
    uint256 defaultLandType,
    uint160 seedMask,
    uint256 globalBoosterId,
    uint256 maxGroupIdNumber,
    uint256 chunkSize,
    uint256 maxLevel,
    uint256[7] memory categoryMaxBoost,
    uint256[3] memory maxBoosts,
    uint256[] memory startingItems,
    uint256[] memory startingItemsQuantities
  ) internal {
    bytes memory _staticData = encodeStatic(
      cookingCost,
      softCostPerSquare,
      landNonce,
      initialLimitX,
      initialLimitY,
      minStartingX,
      minStartingY,
      totalLandSlotsSold,
      startTime,
      defaultLandType,
      seedMask,
      globalBoosterId,
      maxGroupIdNumber,
      chunkSize,
      maxLevel
    );

    EncodedLengths _encodedLengths = encodeLengths(categoryMaxBoost, maxBoosts, startingItems, startingItemsQuantities);
    bytes memory _dynamicData = encodeDynamic(categoryMaxBoost, maxBoosts, startingItems, startingItemsQuantities);

    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function set(CafeCosmosConfigData memory _table) internal {
    bytes memory _staticData = encodeStatic(
      _table.cookingCost,
      _table.softCostPerSquare,
      _table.landNonce,
      _table.initialLimitX,
      _table.initialLimitY,
      _table.minStartingX,
      _table.minStartingY,
      _table.totalLandSlotsSold,
      _table.startTime,
      _table.defaultLandType,
      _table.seedMask,
      _table.globalBoosterId,
      _table.maxGroupIdNumber,
      _table.chunkSize,
      _table.maxLevel
    );

    EncodedLengths _encodedLengths = encodeLengths(
      _table.categoryMaxBoost,
      _table.maxBoosts,
      _table.startingItems,
      _table.startingItemsQuantities
    );
    bytes memory _dynamicData = encodeDynamic(
      _table.categoryMaxBoost,
      _table.maxBoosts,
      _table.startingItems,
      _table.startingItemsQuantities
    );

    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function _set(CafeCosmosConfigData memory _table) internal {
    bytes memory _staticData = encodeStatic(
      _table.cookingCost,
      _table.softCostPerSquare,
      _table.landNonce,
      _table.initialLimitX,
      _table.initialLimitY,
      _table.minStartingX,
      _table.minStartingY,
      _table.totalLandSlotsSold,
      _table.startTime,
      _table.defaultLandType,
      _table.seedMask,
      _table.globalBoosterId,
      _table.maxGroupIdNumber,
      _table.chunkSize,
      _table.maxLevel
    );

    EncodedLengths _encodedLengths = encodeLengths(
      _table.categoryMaxBoost,
      _table.maxBoosts,
      _table.startingItems,
      _table.startingItemsQuantities
    );
    bytes memory _dynamicData = encodeDynamic(
      _table.categoryMaxBoost,
      _table.maxBoosts,
      _table.startingItems,
      _table.startingItemsQuantities
    );

    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Decode the tightly packed blob of static data using this table's field layout.
   */
  function decodeStatic(
    bytes memory _blob
  )
    internal
    pure
    returns (
      uint256 cookingCost,
      uint256 softCostPerSquare,
      uint256 landNonce,
      uint256 initialLimitX,
      uint256 initialLimitY,
      uint256 minStartingX,
      uint256 minStartingY,
      uint256 totalLandSlotsSold,
      uint256 startTime,
      uint256 defaultLandType,
      uint160 seedMask,
      uint256 globalBoosterId,
      uint256 maxGroupIdNumber,
      uint256 chunkSize,
      uint256 maxLevel
    )
  {
    cookingCost = (uint256(Bytes.getBytes32(_blob, 0)));

    softCostPerSquare = (uint256(Bytes.getBytes32(_blob, 32)));

    landNonce = (uint256(Bytes.getBytes32(_blob, 64)));

    initialLimitX = (uint256(Bytes.getBytes32(_blob, 96)));

    initialLimitY = (uint256(Bytes.getBytes32(_blob, 128)));

    minStartingX = (uint256(Bytes.getBytes32(_blob, 160)));

    minStartingY = (uint256(Bytes.getBytes32(_blob, 192)));

    totalLandSlotsSold = (uint256(Bytes.getBytes32(_blob, 224)));

    startTime = (uint256(Bytes.getBytes32(_blob, 256)));

    defaultLandType = (uint256(Bytes.getBytes32(_blob, 288)));

    seedMask = (uint160(Bytes.getBytes20(_blob, 320)));

    globalBoosterId = (uint256(Bytes.getBytes32(_blob, 340)));

    maxGroupIdNumber = (uint256(Bytes.getBytes32(_blob, 372)));

    chunkSize = (uint256(Bytes.getBytes32(_blob, 404)));

    maxLevel = (uint256(Bytes.getBytes32(_blob, 436)));
  }

  /**
   * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.
   */
  function decodeDynamic(
    EncodedLengths _encodedLengths,
    bytes memory _blob
  )
    internal
    pure
    returns (
      uint256[7] memory categoryMaxBoost,
      uint256[3] memory maxBoosts,
      uint256[] memory startingItems,
      uint256[] memory startingItemsQuantities
    )
  {
    uint256 _start;
    uint256 _end;
    unchecked {
      _end = _encodedLengths.atIndex(0);
    }
    categoryMaxBoost = toStaticArray_uint256_7(SliceLib.getSubslice(_blob, _start, _end).decodeArray_uint256());

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(1);
    }
    maxBoosts = toStaticArray_uint256_3(SliceLib.getSubslice(_blob, _start, _end).decodeArray_uint256());

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(2);
    }
    startingItems = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_uint256());

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(3);
    }
    startingItemsQuantities = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_uint256());
  }

  /**
   * @notice Decode the tightly packed blobs using this table's field layout.
   * @param _staticData Tightly packed static fields.
   * @param _encodedLengths Encoded lengths of dynamic fields.
   * @param _dynamicData Tightly packed dynamic fields.
   */
  function decode(
    bytes memory _staticData,
    EncodedLengths _encodedLengths,
    bytes memory _dynamicData
  ) internal pure returns (CafeCosmosConfigData memory _table) {
    (
      _table.cookingCost,
      _table.softCostPerSquare,
      _table.landNonce,
      _table.initialLimitX,
      _table.initialLimitY,
      _table.minStartingX,
      _table.minStartingY,
      _table.totalLandSlotsSold,
      _table.startTime,
      _table.defaultLandType,
      _table.seedMask,
      _table.globalBoosterId,
      _table.maxGroupIdNumber,
      _table.chunkSize,
      _table.maxLevel
    ) = decodeStatic(_staticData);

    (_table.categoryMaxBoost, _table.maxBoosts, _table.startingItems, _table.startingItemsQuantities) = decodeDynamic(
      _encodedLengths,
      _dynamicData
    );
  }

  /**
   * @notice Delete all data for given keys.
   */
  function deleteRecord() internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /**
   * @notice Delete all data for given keys.
   */
  function _deleteRecord() internal {
    bytes32[] memory _keyTuple = new bytes32[](0);

    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);
  }

  /**
   * @notice Tightly pack static (fixed length) data using this table's schema.
   * @return The static data, encoded into a sequence of bytes.
   */
  function encodeStatic(
    uint256 cookingCost,
    uint256 softCostPerSquare,
    uint256 landNonce,
    uint256 initialLimitX,
    uint256 initialLimitY,
    uint256 minStartingX,
    uint256 minStartingY,
    uint256 totalLandSlotsSold,
    uint256 startTime,
    uint256 defaultLandType,
    uint160 seedMask,
    uint256 globalBoosterId,
    uint256 maxGroupIdNumber,
    uint256 chunkSize,
    uint256 maxLevel
  ) internal pure returns (bytes memory) {
    return
      abi.encodePacked(
        cookingCost,
        softCostPerSquare,
        landNonce,
        initialLimitX,
        initialLimitY,
        minStartingX,
        minStartingY,
        totalLandSlotsSold,
        startTime,
        defaultLandType,
        seedMask,
        globalBoosterId,
        maxGroupIdNumber,
        chunkSize,
        maxLevel
      );
  }

  /**
   * @notice Tightly pack dynamic data lengths using this table's schema.
   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).
   */
  function encodeLengths(
    uint256[7] memory categoryMaxBoost,
    uint256[3] memory maxBoosts,
    uint256[] memory startingItems,
    uint256[] memory startingItemsQuantities
  ) internal pure returns (EncodedLengths _encodedLengths) {
    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
    unchecked {
      _encodedLengths = EncodedLengthsLib.pack(
        categoryMaxBoost.length * 32,
        maxBoosts.length * 32,
        startingItems.length * 32,
        startingItemsQuantities.length * 32
      );
    }
  }

  /**
   * @notice Tightly pack dynamic (variable length) data using this table's schema.
   * @return The dynamic data, encoded into a sequence of bytes.
   */
  function encodeDynamic(
    uint256[7] memory categoryMaxBoost,
    uint256[3] memory maxBoosts,
    uint256[] memory startingItems,
    uint256[] memory startingItemsQuantities
  ) internal pure returns (bytes memory) {
    return
      abi.encodePacked(
        EncodeArray.encode(fromStaticArray_uint256_7(categoryMaxBoost)),
        EncodeArray.encode(fromStaticArray_uint256_3(maxBoosts)),
        EncodeArray.encode((startingItems)),
        EncodeArray.encode((startingItemsQuantities))
      );
  }

  /**
   * @notice Encode all of a record's fields.
   * @return The static (fixed length) data, encoded into a sequence of bytes.
   * @return The lengths of the dynamic fields (packed into a single bytes32 value).
   * @return The dynamic (variable length) data, encoded into a sequence of bytes.
   */
  function encode(
    uint256 cookingCost,
    uint256 softCostPerSquare,
    uint256 landNonce,
    uint256 initialLimitX,
    uint256 initialLimitY,
    uint256 minStartingX,
    uint256 minStartingY,
    uint256 totalLandSlotsSold,
    uint256 startTime,
    uint256 defaultLandType,
    uint160 seedMask,
    uint256 globalBoosterId,
    uint256 maxGroupIdNumber,
    uint256 chunkSize,
    uint256 maxLevel,
    uint256[7] memory categoryMaxBoost,
    uint256[3] memory maxBoosts,
    uint256[] memory startingItems,
    uint256[] memory startingItemsQuantities
  ) internal pure returns (bytes memory, EncodedLengths, bytes memory) {
    bytes memory _staticData = encodeStatic(
      cookingCost,
      softCostPerSquare,
      landNonce,
      initialLimitX,
      initialLimitY,
      minStartingX,
      minStartingY,
      totalLandSlotsSold,
      startTime,
      defaultLandType,
      seedMask,
      globalBoosterId,
      maxGroupIdNumber,
      chunkSize,
      maxLevel
    );

    EncodedLengths _encodedLengths = encodeLengths(categoryMaxBoost, maxBoosts, startingItems, startingItemsQuantities);
    bytes memory _dynamicData = encodeDynamic(categoryMaxBoost, maxBoosts, startingItems, startingItemsQuantities);

    return (_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Encode keys as a bytes32 array using this table's field layout.
   */
  function encodeKeyTuple() internal pure returns (bytes32[] memory) {
    bytes32[] memory _keyTuple = new bytes32[](0);

    return _keyTuple;
  }
}

/**
 * @notice Cast a dynamic array to a static array.
 * @dev In memory static arrays are just dynamic arrays without the 32 length bytes,
 * so this function moves the pointer to the first element of the dynamic array.
 * If the length of the dynamic array is smaller than the static length,
 * the function returns an uninitialized array to avoid memory corruption.
 * @param _value The dynamic array to cast.
 * @return _result The static array.
 */
function toStaticArray_uint256_7(uint256[] memory _value) pure returns (uint256[7] memory _result) {
  if (_value.length < 7) {
    // return an uninitialized array if the length is smaller than the fixed length to avoid memory corruption
    return _result;
  } else {
    // in memory static arrays are just dynamic arrays without the 32 length bytes
    // (without the length check this could lead to memory corruption)
    assembly {
      _result := add(_value, 0x20)
    }
  }
}

/**
 * @notice Cast a dynamic array to a static array.
 * @dev In memory static arrays are just dynamic arrays without the 32 length bytes,
 * so this function moves the pointer to the first element of the dynamic array.
 * If the length of the dynamic array is smaller than the static length,
 * the function returns an uninitialized array to avoid memory corruption.
 * @param _value The dynamic array to cast.
 * @return _result The static array.
 */
function toStaticArray_uint256_3(uint256[] memory _value) pure returns (uint256[3] memory _result) {
  if (_value.length < 3) {
    // return an uninitialized array if the length is smaller than the fixed length to avoid memory corruption
    return _result;
  } else {
    // in memory static arrays are just dynamic arrays without the 32 length bytes
    // (without the length check this could lead to memory corruption)
    assembly {
      _result := add(_value, 0x20)
    }
  }
}

/**
 * @notice Copy a static array to a dynamic array.
 * @dev Static arrays don't have a length prefix, so this function copies the memory from the static array to a new dynamic array.
 * @param _value The static array to copy.
 * @return _result The dynamic array.
 */
function fromStaticArray_uint256_7(uint256[7] memory _value) pure returns (uint256[] memory _result) {
  _result = new uint256[](7);
  uint256 fromPointer;
  uint256 toPointer;
  assembly {
    fromPointer := _value
    toPointer := add(_result, 0x20)
  }
  Memory.copy(fromPointer, toPointer, 224);
}

/**
 * @notice Copy a static array to a dynamic array.
 * @dev Static arrays don't have a length prefix, so this function copies the memory from the static array to a new dynamic array.
 * @param _value The static array to copy.
 * @return _result The dynamic array.
 */
function fromStaticArray_uint256_3(uint256[3] memory _value) pure returns (uint256[] memory _result) {
  _result = new uint256[](3);
  uint256 fromPointer;
  uint256 toPointer;
  assembly {
    fromPointer := _value
    toPointer := add(_result, 0x20)
  }
  Memory.copy(fromPointer, toPointer, 96);
}
